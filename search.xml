<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>raft协议的学习</title>
      <link href="/2022/03/30/raft/"/>
      <url>/2022/03/30/raft/</url>
      
        <content type="html"><![CDATA[<p>本文基于论文<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">In Search of an Understandable Consensus Algorithm</a>对raft协议进行分析学习</p><h1>前置知识</h1><h2 id="分布式存储系统">分布式存储系统</h2><p>  分布式存储系统，是将数据分散存储在多台独立的设备上。传统的网络存储系统采用集中的存储服务器存放所有数据，存储服务器成为系统性能的瓶颈，也是可靠性和安全性的焦点，不能满足大规模存储应用的需要。分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。</p><h2 id="分布式系统的三大特性CAP">分布式系统的三大特性CAP</h2><ul><li>一致性（Consistency）：多个数据副本是否能够保持一致；</li><li>可用性（Availability）：每次请求都能获取非错的响应，但无法保证获取的数据是否最新；</li><li>分区容忍性（Partition tolerance）：网络分区指分布式系统中的各个节点，任意分区（节点）网络故障时，系统仍需要可以对外提供服务。</li></ul><img src="https://cdn.jsdelivr.net/gh/Hor1zontal/BLOG_IMG/2022/3/202203301500346.png" alt = "CAP" width="400" height="300"/><p>  分布式系统不可能同时满足这三个特性，最多只能同时满足其中两项，<strong>分区容忍性必不可少</strong>，因为需要总是假设网络不是可靠的，所以最终要在可用性和一致性之间做选择。</p><p>可用性与一致性是冲突的，在多节点之间进行数据同步时</p><ul><li>为了保持一致性（CP），就需要让系统暂停服务，等待数据同步完成</li><li>为了保证可用性（AP），同步过程中继续提供服务，读取的数据可能不一致</li></ul><table><thead><tr><th>CAP</th><th>适用场景</th><th>解释</th></tr></thead><tbody><tr><td>CA</td><td>几乎不存在</td><td>在分布式系统中，P必然存在，除非适用单机，要提升分区可靠性，需要通过提升基础设施的可靠性实现</td></tr><tr><td>CP</td><td>分布式数据库（redis、HBase、zk、etcd）</td><td>分布式数据库极端情况下优先保证数据一致性</td></tr><tr><td>AP</td><td>12306购票、淘宝购物</td><td>保证服务可用，购票下单后，一段时间后系统提示余票不足</td></tr></tbody></table><h2 id="分布式一致性raft">分布式一致性raft</h2><p>  raft牺牲了A，保留了CP。分布式存储系统通常通过维护多个副本来进行容错，提高系统的可用性。要实现此目标，就必须要解决分布式存储系统的最核心问题：维护多个副本的一致。</p><h2 id="什么是分布式一致性？">什么是分布式一致性？</h2><p>  分布式系统的一致性是构建具有容错性（fault-tolerant）的分布式系统的基础。在一个具有一致性的性质的集群里，同一时刻所有的节点对存储在其中的某个值都有相同的结果，即对其分享的存储保持一致。集群具有自动恢复的性质，当少数节点失效的时候不影响集群的正常工作，当大多数集群中的节点失效的时候，集群则会停止服务（不会返回一个错误的结果）。<br>一致性协议就是用来干这事的，用来保证即使在部分（确切来说是小部分）副本宕机的情况下，系统仍然能正常对外提供服务。一致性协议通常基于replicated state machines，即所有节点都从同一个state出发，都经过同样的一些操作序列（log），最后到达同样的state。</p><h2 id="分布式高并发">分布式高并发</h2><p>//todo<br>同样的执行顺序，分布式系统如何实现高并发？</p><h1>Raft协议</h1><h2 id="Raft协议概述">Raft协议概述</h2><blockquote><p>It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems</p></blockquote><p>  Raft协议在功能上是等同于（Multi-）Paxos，并且在性能、可靠性、可用性方面是不输于Paxos的。但是raft协议的结构却跟Paxos是不同的，这使得raft协议更易于理解，并且让开发人员可以在很短的时间内开发出一个可用的系统。在raft出现之前，Paxos一直在共识算法中保持着统治级的地位，不幸的是，Paxos很难去理解。</p><blockquote><p>It was important not just for the algorithm to work, but for it to be obvious why it works.</p></blockquote><p>  重要的不仅是算法能够有效，更重要的是让大家很容易就知道他是如何运行的。</p><blockquote><p>In designing Raft we applied specific techniques to improve understandability, including decomposition (Raft separates leader election, log replication, and safety) and state space reduction (relative to Paxos, Raft reduces the degree of nondeterminism and the ways servers can be inconsistent with each other)</p></blockquote><p>  Raft算法主要做了两个工作去让大家去易于理解</p><ul><li>问题分解（decomposition）：将&quot;复制集中节点一致性&quot;这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。raft中子问题包括：leader elect，log replication，safety，membership changes</li><li>状态简化（state space reduction）：对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry）。</li></ul><h2 id="Basics">Basics</h2><blockquote><p>任何一个节点都处于以下三种状态之一</p></blockquote><ul><li>leader</li><li>follower</li><li>candidate</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hor1zontal/BLOG_IMG/2022/3/202203301710546.png" alt=""></p><p>  可以看出所有节点启动时都是follower状态；在一段时间内如果没有收到来自leader的心跳，从follower切换到candidate，发起选举；如果收到majority的造成票（含自己的一票）则切换到leader状态；如果发现其他节点比自己更新，则主动切换到follower。</p><p>  总之，系统中最多只有一个leader，如果在一段时间里发现没有leader，则大家通过选举-投票选出leader。leader会不停的给follower发心跳消息，表明自己的存活状态。如果leader故障，那么follower会转换成candidate，重新选出leader。</p><blockquote><p>term（任期的概念）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Hor1zontal/BLOG_IMG/2022/3/202203301720661.png" alt=""></p><p>  从上面可以看出，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫term。</p><p>  term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。</p><blockquote><p>节点之间通信通过RPC，basic consensus algorithm使用两种RPC请求。</p></blockquote><ul><li>RequestVote RPC：由candidate在选举期间发起的；</li><li>AppendEntries RPC：被leader发起复制日志，并提供心跳。</li><li>(第三个RPC，用于在服务器之间传输快照。如果服务器没有及时收到响应，则会重试RPC，并并行发出RPC以获得最佳性能)</li></ul><blockquote><p>复制状态机架构（Replicated state machine architecture）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Hor1zontal/BLOG_IMG/2022/3/202203311546086.png" alt=""></p><h2 id="Leader-election">Leader election</h2><p>  一个节点启动，开始是follower，一个节点一直保持follower状态只要它能从leader或者candidate收到有效的RPC请求。</p><p>  leader一段时间给所有的follower发送一个心跳包(AppendEntries RPCs that carry no log entries);如果一个follower在一段时间没有收到RPC请求，则称之为election timeout(选举超时)，然后它就假设系统中没有leader，并且发起一个选举来选择新的leader。</p><p>  选举开始，发起选举的follower节点的term+1，并且转换为candidate状态，然后该节点为自己投票并且在集群中给其他节点发送RequestVote RPC请求。这个节点会一直保持在candidate状态，直到以下三个事情发生：</p><ul><li><p>it wins the election。该节点赢得选举；</p><ul><li>而一个节点(candidate)赢得选举的情况是它赢得了集群中大多数（&gt;1/2）节点(相同的term)的投票(包含自己的票)。每个节点只能投一票。</li><li>//todo The majority rule ensures that at most one candidate can win the election for a particular term（候选者知道的信息不能比自己的少）</li><li>first-come-first-served先来先得</li></ul></li><li><p>another server establishes itself as leader。收到其他自称为leader的AppendEntries RPC，只有当这个leader的term比自己大或者相等，才会承认该leader并进入follower状态，否则继续保持candidate状态。</p></li><li><p>a period of time goes by with no winner。一段时间过后，没有节点赢得选举，导致这一结果的原因是，如果许多follower同时称为candidate，选票就会被平分，所以就没有candidate获得大多数的选票。当这种情况发生的时候，每个candidate会超时并且重新发起一个新的选举（term+1）来发起RequestVote RPC。然而，如果没有额外的措施，这种情况可能会无限期地重复。所以采用随机选举超时（randomized election timeouts）的方式来确保split vote很少出现并能够被快速解决。</p></li></ul><h2 id="Log-replication">Log replication</h2><p>   一旦一个节点当选leader，它就开始处理客户端的请求（request）。每一个客户端的请求包含着复制状态机的一条待执行的命令（command）。leader将这个指令当作一个新的entry（包含Term ID和command），然后发送AppendEntries RPC告诉其他的节点复制entry。当entry被安全地复制之后，leader应用entry到状态机，并且返回执行的结果给客户端。如果follower宕机，执行偏慢，或者网络丢包，leader将一直发送AppendEntries RPC直到所有的follower都最终存储了所有的log entries。（即跟leader的entries一致）。</p><p><img src="https://cdn.jsdelivr.net/gh/Hor1zontal/BLOG_IMG/2022/3/202203311504795.png" alt=""></p><p>Figure6：日志由entries组成，并且被序列化。每一条entry内都含有term ID和command</p><blockquote><p>The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed.</p></blockquote><p>  leader决定何时安全地apply日志到状态机,这个entry就被称为已提交</p><blockquote><p>A log entry is committed once the leader that created the entry has replicated it on a majority of the servers.</p></blockquote><p>  一个leader创建的entry一旦被复制到大部分的节点上后，这个entry就被称为<em><strong>committed</strong></em>。</p><blockquote><p>Once a follower learns that a log entry is committed, it applies the entry to its local state machine<br>一旦follower知道一个entry被committed，它就应用这个entry到本地状态机上。</p></blockquote><h2 id="Safety">Safety</h2><p>衡量一个分布式算法，有许多属性，如</p><ul><li>safety：nothing bad happens,</li><li>liveness： something good eventually happens.</li></ul><p>  在任何系统模型下，都需要满足safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是safety属性。而raft最终会让所有节点状态一致，这属于liveness属性。<br><img src="https://cdn.jsdelivr.net/gh/Hor1zontal/BLOG_IMG/2022/3/202203311538296.png" alt=""></p><h3 id="Election-Safety">Election Safety</h3><p>  选举安全性，即<strong>任意一任期内最多一个leader被选出</strong>。这一点非常重要，在一个复制集中任何时刻只能有一个leader。系统中同时有多余一个leader，被称之为脑裂（brain split），这是非常严重的问题，会导致数据的覆盖丢失。在raft中，两点保证了这个属性：</p><ul><li>一个节点某一任期内最多只能投一票</li><li>只有获得majority投票的节点才能成为leader</li></ul><h3 id="Leader-Append-Only">Leader Append-Only</h3><p>leader从来不覆写和删除entries，只会append新的entries。</p><h3 id="Log-Matching">Log Matching</h3><ul><li>If two entries in different logs have the same index and term, then they store the same command.</li><li>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.</li></ul><p>  首先，leader在某一term的任一位置只会创建一个log entry，且log entry是append-only。其次，consistency check。leader在AppendEntries中包含最新log entry之前的一个log 的term和index，如果follower在对应的term index找不到日志，那么就会告知leader不一致。<br>  在没有异常的情况下，log matching是很容易满足的，但如果出现了node crash，情况就会变得负责。比如下图<br><img src="https://cdn.jsdelivr.net/gh/Hor1zontal/BLOG_IMG/2022/3/202203311652938.png" alt=""><br>上图的a-f为某个follower可能存在的六种状态</p><ul><li>比leader日志少，如ab</li><li>比leader日志多，如cd</li><li>某些位置比leader多，某些日志比leader少，如ef（多少是针对任期而言的）</li></ul><blockquote><p>In Raft, the leader handles inconsistencies by forcing the followers’ logs to duplicate its own。</p></blockquote><p>在Raft中，当出现了leader与follower不一致的情况，leader通过强制让follower复制logs和自己一样来处理不一致性的问题。</p><p>leader通过维护一个<em>nextIndex</em>数组来记录下一个leader要发送到每个follower的index。初始化为leader最后一个log index加1。</p><p>流程如下</p><blockquote><p>s1 leader 初始化nextIndex[x]为 leader最后一个log index + 1<br>s2 AppendEntries里prevLogTerm prevLogIndex来自 logs[nextIndex[x] - 1]<br>s3 如果follower判断prevLogIndex位置的log term不等于prevLogTerm，那么返回 False，否则返回True<br>s4 leader收到follower的回复，如果返回值是False，则nextIndex[x] -= 1, 跳转到s2. 否则<br>s5 同步nextIndex[x]后的<strong>所有log entries</strong>（一次性同步所有的）</p></blockquote><h3 id="leader-completeness">leader completeness</h3><p>leader完整性：如果一个log entry在某个任期被提交（committed），那么这条日志一定会出现在所有更高term的leader的日志里面。这个跟leader election、log replication都有关。</p><ul><li>一个日志被复制到majority节点才算committed</li><li>一个节点得到majority的投票才能成为leader，而节点A给节点B投票的其中一个前提是，B的日志不能比A的日志旧。下面的引文指处了如何判断日志的新旧</li></ul><p>raft与其他协议（Viewstamped Replication、mongodb）不同，raft始终保证leade包含最新的已提交的日志，因此leader不会从follower catchup日志，这也大大简化了系统的复杂度。</p><h3 id="state-machine-safety">state machine safety</h3><p>如果一个节点已经apply一个给定index的log entry给它的状态机，不能有其他节点在相同的index apply不同的log entry。<br><img src="https://cdn.jsdelivr.net/gh/Hor1zontal/BLOG_IMG/2022/3/202203311933175.png" alt=""></p><p>  上图是一个较为复杂的情况。在时刻(a), s1是leader，在term2提交的日志只赋值到了s1 s2两个节点就crash了。在时刻（b), s5成为了term 3的leader，日志只赋值到了s5，然后crash。然后在©时刻，s1又成为了term 4的leader，开始赋值日志，于是把term2的日志复制到了s3，此刻，可以看出term2对应的日志已经被复制到了majority，因此是committed，可以被状态机应用。不幸的是，接下来（d）时刻，s1又crash了，s5重新当选，然后将term3的日志复制到所有节点，这就出现了一种奇怪的现象：被复制到大多数节点（或者说可能已经应用）的日志被回滚。</p><p>  究其根本，是因为term4时的leader s1在（C）时刻提交了之前term2任期的日志。为了杜绝这种情况的发生：</p><blockquote><p>Raft never commits log entries from previous terms by counting replicas.<br>Only log entries from the leader’s current term are committed by counting replicas; once an entry from the current term has been committed in this way, then all prior entries are committed indirectly because of the Log Matching Property.</p></blockquote><p>  也就是说，某个leader选举成功之后，不会直接提交前任leader时期的日志，而是通过提交当前任期的日志的时候“顺手”把之前的日志也提交了，具体怎么实现了，在log matching部分有详细介绍。那么问题来了，如果leader被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的log。</p><blockquote><p>Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term.</p></blockquote><p>  因此，在上图中，不会出现（C）时刻的情况，即term4任期的leader s1不会复制term2的日志到s3。而是如同(e)描述的情况，通过复制-提交 term4的日志顺便提交term2的日志。如果term4的日志提交成功，那么term2的日志也一定提交成功，此时即使s1crash，s5也不会重新当选。</p><h2 id="corner-case">corner case</h2><p>Section 5.4 discusses somesubtleties when applying this rule after leader changes,and it also shows that this definition of commitment is safe.</p><h3 id="stale-leader">stale leader</h3><p>  raft保证Election safety，即一个任期内最多只有一个leader，但在网络分割（network partition）的情况下，可能会出现两个leader，但两个leader所处的任期是不同的。如下图所示</p><h3 id="leader-crash">leader crash</h3><p>  follower的crash处理方式相对简单，leader只要不停的给follower发消息即可。当leader crash的时候，事情就会变得复杂。在<a href="https://www.cnblogs.com/mindwind/p/5231986.html">这篇文章</a>中，作者就给出了一个更新请求的流程图。</p><h1>总结</h1><p>对raft协议有个简单的了解<a href="http://thesecretlivesofdata.com/raft/">动画</a></p><h1>References</h1><p><a href="https://www.cnblogs.com/xybaby/p/10124083.html#_labelTop">https://www.cnblogs.com/xybaby/p/10124083.html#_labelTop</a><br><a href="https://www.cnblogs.com/mindwind/p/5231986.html">https://www.cnblogs.com/mindwind/p/5231986.html</a><br><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a><br><a href="https://raft.github.io/">https://raft.github.io/</a><br><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> raft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 共识算法 </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语法学习</title>
      <link href="/2022/03/30/python/"/>
      <url>/2022/03/30/python/</url>
      
        <content type="html"><![CDATA[<h1>Python</h1><h2 id="语法">语法</h2><h3 id="turle-海龟画图">turle 海龟画图</h3><ul><li>坐标原点在中心，跟坐标系一样 默认向x轴正方向</li></ul><h3 id="可以使用Python中内置的函数对变量类型进行转换。">可以使用Python中内置的函数对变量类型进行转换。</h3><ul><li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li><li><code>float()</code>：将一个字符串转换成浮点数。</li><li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li><li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li><li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li></ul><h3 id="占位符">占位符</h3><ul><li><code>%d</code>是整数的占位符</li><li><code>%f</code>是小数的占位符</li><li><code>%%</code>表示百分号<br><code>print('%.1f华氏度 = %.1f摄氏度' % (f, c))</code><br>说明：在使用print函数输出时，也可以对字符串内容进行格式化处理，上面print函数中的字符串%.1f是一个占位符，稍后会由一个float类型的变量值替换掉它。同理，如果字符串中有%d，后面可以用一个int类型的变量值替换掉它，而%s会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中{f:.1f}和{c:.1f}可以先看成是{f}和{c}，表示输出时会用变量f和变量c的值替换掉这两个占位符，后面的:.1f表示这是一个浮点数，小数点后保留1位有效数字。</li></ul><p><code>print(f'&#123;f:.1f&#125;华氏度 = &#123;c:.1f&#125;摄氏度')</code></p><h3 id="运算符">运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code> <code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code> <code>+</code> <code>-</code></td><td>按位取反, 正负号</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code> <code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code> <code>|</code></td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code> <code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code>  <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code> <code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> `</td><td>=<code> </code>^=<code> </code>&gt;&gt;=<code> </code>&lt;&lt;=`</td></tr></tbody></table><h3 id="if语句">if语句</h3><p><code>if...elif...else</code><br><code>if...else</code></p><h3 id="循环结构">循环结构</h3><p><em>for-in循环</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    <span class="built_in">sum</span> += x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><ul><li><code>range(101)</code>：可以用来产生0到100范围的整数，需要注意的是取不到101。</li><li><code>range(1, 101)</code>：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。</li><li><code>range(1, 101, 2)</code>：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。</li><li><code>range(100, 0, -2)</code>：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。</li></ul><p><em>while循环</em></p><h3 id="使用字符串">使用字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line">s2 = <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line"><span class="comment"># 以三个双引号或单引号开头的字符串可以折行</span></span><br><span class="line">s3 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">hello, </span></span><br><span class="line"><span class="string">world!</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1, s2, s3, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以在字符串中使用<code>\</code>（反斜杠）来表示转义，也就是说<code>\</code>后面的字符不再是它原来的意义，例如：<code>\n</code>不是代表反斜杠和字符n，而是表示换行；而<code>\t</code>也不是代表反斜杠和字符t，而是表示制表符。所以如果想在字符串中表示<code>'</code>要写成<code>\'</code>，同理想表示<code>\</code>要写成<code>\\</code>。可以运行下面的代码看看会输出什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;\&#x27;hello, world!\&#x27;&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;\n\\hello, world!\\\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s1, s2, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;hello &#x27;</span> * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(s1) <span class="comment"># hello hello hello </span></span><br><span class="line">s2 = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">s1 += s2</span><br><span class="line"><span class="built_in">print</span>(s1) <span class="comment"># hello hello hello world</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ll&#x27;</span> <span class="keyword">in</span> s1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;good&#x27;</span> <span class="keyword">in</span> s1) <span class="comment"># False</span></span><br><span class="line">str2 = <span class="string">&#x27;abc123456&#x27;</span></span><br><span class="line"><span class="comment"># 从字符串中取出指定位置的字符(下标运算)</span></span><br><span class="line"><span class="built_in">print</span>(str2[<span class="number">2</span>]) <span class="comment"># c</span></span><br><span class="line"><span class="comment"># 字符串切片(从指定的开始索引到指定的结束索引)</span></span><br><span class="line"><span class="comment"># 切片[]取左不取右</span></span><br><span class="line"><span class="built_in">print</span>(str2[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment"># c12</span></span><br><span class="line"><span class="built_in">print</span>(str2[<span class="number">2</span>:]) <span class="comment"># c123456</span></span><br><span class="line"><span class="built_in">print</span>(str2[<span class="number">2</span>::<span class="number">2</span>]) <span class="comment"># c246</span></span><br><span class="line"><span class="built_in">print</span>(str2[::<span class="number">2</span>]) <span class="comment"># ac246</span></span><br><span class="line"><span class="built_in">print</span>(str2[::-<span class="number">1</span>]) <span class="comment"># 654321cba</span></span><br><span class="line"><span class="built_in">print</span>(str2[-<span class="number">3</span>:-<span class="number">1</span>]) <span class="comment"># 45</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line"><span class="comment"># 通过内置函数len计算字符串的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(str1)) <span class="comment"># 13</span></span><br><span class="line"><span class="comment"># 获得字符串首字母大写的拷贝</span></span><br><span class="line"><span class="built_in">print</span>(str1.capitalize()) <span class="comment"># Hello, world!</span></span><br><span class="line"><span class="comment"># 获得字符串每个单词首字母大写的拷贝</span></span><br><span class="line"><span class="built_in">print</span>(str1.title()) <span class="comment"># Hello, World!</span></span><br><span class="line"><span class="comment"># 获得字符串变大写后的拷贝</span></span><br><span class="line"><span class="built_in">print</span>(str1.upper()) <span class="comment"># HELLO, WORLD!</span></span><br><span class="line"><span class="comment"># 从字符串中查找子串所在位置</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(<span class="string">&#x27;or&#x27;</span>)) <span class="comment"># 8</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(<span class="string">&#x27;shit&#x27;</span>)) <span class="comment"># -1</span></span><br><span class="line"><span class="comment"># 与find类似但找不到子串时会引发异常</span></span><br><span class="line"><span class="comment"># print(str1.index(&#x27;or&#x27;))</span></span><br><span class="line"><span class="comment"># print(str1.index(&#x27;shit&#x27;))</span></span><br><span class="line"><span class="comment"># 检查字符串是否以指定的字符串开头</span></span><br><span class="line"><span class="built_in">print</span>(str1.startswith(<span class="string">&#x27;He&#x27;</span>)) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(str1.startswith(<span class="string">&#x27;hel&#x27;</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 检查字符串是否以指定的字符串结尾</span></span><br><span class="line"><span class="built_in">print</span>(str1.endswith(<span class="string">&#x27;!&#x27;</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 将字符串以指定的宽度居中并在两侧填充指定的字符</span></span><br><span class="line"><span class="built_in">print</span>(str1.center(<span class="number">50</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="comment"># 将字符串以指定的宽度靠右放置左侧填充指定的字符</span></span><br><span class="line"><span class="built_in">print</span>(str1.rjust(<span class="number">50</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">str2 = <span class="string">&#x27;abc123456&#x27;</span></span><br><span class="line"><span class="comment"># 检查字符串是否由数字构成</span></span><br><span class="line"><span class="built_in">print</span>(str2.isdigit())  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 检查字符串是否以字母构成</span></span><br><span class="line"><span class="built_in">print</span>(str2.isalpha())  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 检查字符串是否以数字和字母构成</span></span><br><span class="line"><span class="built_in">print</span>(str2.isalnum())  <span class="comment"># True</span></span><br><span class="line">str3 = <span class="string">&#x27;  jackfrued@126.com &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"><span class="comment"># 获得字符串修剪左右两侧空格之后的拷贝</span></span><br><span class="line"><span class="built_in">print</span>(str3.strip())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">5</span>, <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%d * %d = %d&#x27;</span> % (a, b, a * b))</span><br></pre></td></tr></table></figure><p>当然，我们也可以用字符串提供的方法来完成字符串的格式，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">5</span>, <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(a, b, a * b))</span><br></pre></td></tr></table></figure><p>Python 3.6以后，格式化字符串还有更为简洁的书写方式，就是在字符串前加上字母<code>f</code>，我们可以使用下面的语法糖来简化上面的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">5</span>, <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span> * <span class="subst">&#123;b&#125;</span> = <span class="subst">&#123;a * b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test_my_site</title>
      <link href="/2022/03/30/test-my-site/"/>
      <url>/2022/03/30/test-my-site/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
            <tag> world </tag>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/30/hello-world/"/>
      <url>/2022/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
            <tag> world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
